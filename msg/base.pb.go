// Code generated by protoc-gen-go. DO NOT EDIT.
// source: base.proto

package msg

import (
	"bytes"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
	"strconv"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DataUserAccount struct {
	UserUID              int64                  `protobuf:"varint,1,opt,name=userUID,proto3" json:"userUID,omitempty"`
	PhoneID              string                 `protobuf:"bytes,2,opt,name=phoneID,proto3" json:"phoneID,omitempty"`
	AccountID            string                 `protobuf:"bytes,3,opt,name=accountID,proto3" json:"accountID,omitempty"`
	Password             string                 `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	Email                string                 `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	XXX_Update           map[string]interface{} `json:"-"`
	XXX_Update2          map[string]interface{} `json:"-"`
	XXX_Key              map[string]interface{} `json:"-"`
	XXX_Add              map[string]interface{} `json:"-"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DataUserAccount) Reset()         { *m = DataUserAccount{} }
func (m *DataUserAccount) String() string { return proto.CompactTextString(m) }
func (*DataUserAccount) ProtoMessage()    {}
func (*DataUserAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{0}
}

func (m *DataUserAccount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DataUserAccount.Unmarshal(m, b)
}
func (m *DataUserAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DataUserAccount.Marshal(b, m, deterministic)
}
func (m *DataUserAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataUserAccount.Merge(m, src)
}
func (m *DataUserAccount) XXX_Size() int {
	return xxx_messageInfo_DataUserAccount.Size(m)
}
func (m *DataUserAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_DataUserAccount.DiscardUnknown(m)
}

var xxx_messageInfo_DataUserAccount proto.InternalMessageInfo

func (m *DataUserAccount) GetName() string {
	var buff bytes.Buffer
	buff.WriteString("DataUserAccount")
	data := strconv.Quote(buff.String())
	return data
}
func (m *DataUserAccount) DBDel() string {
	var buff bytes.Buffer
	buff.WriteString("DELETE FROM ")
	buff.WriteString("DataUserAccount")
	buff.WriteString(" WHERE ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserAccount) DBInsert() string {
	var buff bytes.Buffer
	buff.WriteString("INSERT INTO ")
	buff.WriteString("DataUserAccount")
	buff.WriteString("( ")
	i := 0
	var key bytes.Buffer
	var value bytes.Buffer
	for k, v := range m.XXX_Update {
		if i > 0 {
			key.WriteString(", ")
			value.WriteString(", ")
		}
		key.WriteString(k)
		d := fmt.Sprint(v)
		value.WriteString(d)
		i += 1
	}
	buff.WriteString(key.String())
	buff.WriteString(" ) VALUES ( ")
	buff.WriteString(value.String())
	buff.WriteString(" )")
	return buff.String()
}
func (m *DataUserAccount) DBUpdate() string {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserAccount")
	buff.WriteString(" SET ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserAccount) DBSelect() (s string, ks []string) {
	var buff bytes.Buffer
	buff.WriteString("SELECT ")
	i := 0
	if len(m.XXX_Update) == 0 {
		ks = make([]string, 5)
		ks[0] = "UserUID"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("UserUID")
		i += 1
		ks[1] = "PhoneID"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("PhoneID")
		i += 1
		ks[2] = "AccountID"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("AccountID")
		i += 1
		ks[3] = "Password"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Password")
		i += 1
		ks[4] = "Email"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Email")
		i += 1
	} else {
		ks = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			if i > 0 {
				buff.WriteString(", ")
			}
			buff.WriteString(k)
			ks[j] = k
			j += 1
			i += 1
		}
	}
	buff.WriteString(" FROM ")
	buff.WriteString("DataUserAccount")
	i = 0
	for k, v := range m.XXX_Key {
		if i == 0 {
			buff.WriteString(" WHERE ")
		}
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	s = buff.String()
	return
}
func (m *DataUserAccount) GetFieldID(ks []string) (p []interface{}) {
	if nil == m.XXX_Add {
		m.XXX_Add = make(map[string]interface{})
	}
	m.XXX_Add["UserUID"] = &m.UserUID
	m.XXX_Add["PhoneID"] = &m.PhoneID
	m.XXX_Add["AccountID"] = &m.AccountID
	m.XXX_Add["Password"] = &m.Password
	m.XXX_Add["Email"] = &m.Email
	p = make([]interface{}, len(ks))
	j := 0
	for _, v := range ks {
		if d, ok := m.XXX_Add[v]; ok && nil != d {
			p[j] = d
			j += 1
		}
	}
	return
}
func (m *DataUserAccount) RedisSet(key interface{}) (table string, data []interface{}) {
	table = "DataUserAccount" + "_" + fmt.Sprint(key)
	data = make([]interface{}, 2*len(m.XXX_Update2))
	j := 0
	for k, v := range m.XXX_Update2 {
		data[j] = k
		data[j+1] = v
		j += 2
	}
	return
}
func (m *DataUserAccount) RedisGet(key interface{}) (table string, data []string) {
	table = "DataUserAccount" + "_" + fmt.Sprint(key)
	if len(m.XXX_Update) == 0 {
		data = make([]string, 5)
		data[0] = "UserUID"
		data[1] = "PhoneID"
		data[2] = "AccountID"
		data[3] = "Password"
		data[4] = "Email"
	} else {
		data = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			data[j] = k
			j += 1
		}
	}
	return
}
func (m *DataUserAccount) RedisDel(key interface{}) (table string, data []string) {
	table = "DataUserAccount" + "_" + fmt.Sprint(key)
	data = make([]string, len(m.XXX_Update))
	j := 0
	for k, _ := range m.XXX_Update {
		data[j] = k
		j += 1
	}
	return
}
func (m *DataUserAccount) DoUpdate() (sql, table string, data []interface{}) {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserAccount")
	buff.WriteString(" SET ")
	i := 0
	j := 0
	data = make([]interface{}, 2*len(m.XXX_Update))
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
		data[j] = k
		if val, ok := m.XXX_Update2[k]; ok {
			data[j+1] = val
		} else {
			data[j+1] = nil
		}
		j += 2
		delete(m.XXX_Update, k)
		delete(m.XXX_Update2, k)
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		table = "DataUserAccount" + "_" + d
		i += 1
	}
	sql = buff.String()
	return
}

func (m *DataUserAccount) GetUserUID() int64 {
	if m != nil {
		return m.UserUID
	}
	return 0
}

func (m *DataUserAccount) GetPhoneID() string {
	if m != nil {
		return m.PhoneID
	}
	return ""
}

func (m *DataUserAccount) GetAccountID() string {
	if m != nil {
		return m.AccountID
	}
	return ""
}

func (m *DataUserAccount) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *DataUserAccount) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *DataUserAccount) SetUserUID(data int64) {
	if m != nil {
		m.UserUID = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["UserUID"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["UserUID"] = data
	}
}

func (m *DataUserAccount) SetKeyUserUID(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["UserUID"] = data
	}
}

func (m *DataUserAccount) SetPhoneID(data string) {
	if m != nil {
		m.PhoneID = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["PhoneID"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Update["PhoneID"] = data
	}
}

func (m *DataUserAccount) SetKeyPhoneID(data string) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Key["PhoneID"] = data
	}
}

func (m *DataUserAccount) SetAccountID(data string) {
	if m != nil {
		m.AccountID = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["AccountID"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Update["AccountID"] = data
	}
}

func (m *DataUserAccount) SetKeyAccountID(data string) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Key["AccountID"] = data
	}
}

func (m *DataUserAccount) SetPassword(data string) {
	if m != nil {
		m.Password = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Password"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Update["Password"] = data
	}
}

func (m *DataUserAccount) SetKeyPassword(data string) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Key["Password"] = data
	}
}

func (m *DataUserAccount) SetEmail(data string) {
	if m != nil {
		m.Email = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Email"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Update["Email"] = data
	}
}

func (m *DataUserAccount) SetKeyEmail(data string) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Key["Email"] = data
	}
}

type DataUserBase struct {
	UserUID              int64                  `protobuf:"varint,1,opt,name=userUID,proto3" json:"userUID,omitempty"`
	PlayerID             int64                  `protobuf:"varint,2,opt,name=playerID,proto3" json:"playerID,omitempty"`
	Posx                 float64                `protobuf:"fixed64,3,opt,name=posx,proto3" json:"posx,omitempty"`
	Posy                 float64                `protobuf:"fixed64,4,opt,name=posy,proto3" json:"posy,omitempty"`
	Head                 string                 `protobuf:"bytes,5,opt,name=head,proto3" json:"head,omitempty"`
	Nick                 string                 `protobuf:"bytes,6,opt,name=nick,proto3" json:"nick,omitempty"`
	City                 string                 `protobuf:"bytes,7,opt,name=city,proto3" json:"city,omitempty"`
	Sex                  int32                  `protobuf:"varint,8,opt,name=sex,proto3" json:"sex,omitempty"`
	Age                  int32                  `protobuf:"varint,9,opt,name=age,proto3" json:"age,omitempty"`
	Level                int32                  `protobuf:"varint,10,opt,name=level,proto3" json:"level,omitempty"`
	XXX_Update           map[string]interface{} `json:"-"`
	XXX_Update2          map[string]interface{} `json:"-"`
	XXX_Key              map[string]interface{} `json:"-"`
	XXX_Add              map[string]interface{} `json:"-"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DataUserBase) Reset()         { *m = DataUserBase{} }
func (m *DataUserBase) String() string { return proto.CompactTextString(m) }
func (*DataUserBase) ProtoMessage()    {}
func (*DataUserBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{1}
}

func (m *DataUserBase) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DataUserBase.Unmarshal(m, b)
}
func (m *DataUserBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DataUserBase.Marshal(b, m, deterministic)
}
func (m *DataUserBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataUserBase.Merge(m, src)
}
func (m *DataUserBase) XXX_Size() int {
	return xxx_messageInfo_DataUserBase.Size(m)
}
func (m *DataUserBase) XXX_DiscardUnknown() {
	xxx_messageInfo_DataUserBase.DiscardUnknown(m)
}

var xxx_messageInfo_DataUserBase proto.InternalMessageInfo

func (m *DataUserBase) GetName() string {
	var buff bytes.Buffer
	buff.WriteString("DataUserBase")
	data := strconv.Quote(buff.String())
	return data
}
func (m *DataUserBase) DBDel() string {
	var buff bytes.Buffer
	buff.WriteString("DELETE FROM ")
	buff.WriteString("DataUserBase")
	buff.WriteString(" WHERE ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserBase) DBInsert() string {
	var buff bytes.Buffer
	buff.WriteString("INSERT INTO ")
	buff.WriteString("DataUserBase")
	buff.WriteString("( ")
	i := 0
	var key bytes.Buffer
	var value bytes.Buffer
	for k, v := range m.XXX_Update {
		if i > 0 {
			key.WriteString(", ")
			value.WriteString(", ")
		}
		key.WriteString(k)
		d := fmt.Sprint(v)
		value.WriteString(d)
		i += 1
	}
	buff.WriteString(key.String())
	buff.WriteString(" ) VALUES ( ")
	buff.WriteString(value.String())
	buff.WriteString(" )")
	return buff.String()
}
func (m *DataUserBase) DBUpdate() string {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserBase")
	buff.WriteString(" SET ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserBase) DBSelect() (s string, ks []string) {
	var buff bytes.Buffer
	buff.WriteString("SELECT ")
	i := 0
	if len(m.XXX_Update) == 0 {
		ks = make([]string, 10)
		ks[0] = "UserUID"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("UserUID")
		i += 1
		ks[1] = "PlayerID"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("PlayerID")
		i += 1
		ks[2] = "Posx"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Posx")
		i += 1
		ks[3] = "Posy"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Posy")
		i += 1
		ks[4] = "Head"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Head")
		i += 1
		ks[5] = "Nick"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Nick")
		i += 1
		ks[6] = "City"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("City")
		i += 1
		ks[7] = "Sex"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Sex")
		i += 1
		ks[8] = "Age"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Age")
		i += 1
		ks[9] = "Level"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Level")
		i += 1
	} else {
		ks = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			if i > 0 {
				buff.WriteString(", ")
			}
			buff.WriteString(k)
			ks[j] = k
			j += 1
			i += 1
		}
	}
	buff.WriteString(" FROM ")
	buff.WriteString("DataUserBase")
	i = 0
	for k, v := range m.XXX_Key {
		if i == 0 {
			buff.WriteString(" WHERE ")
		}
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	s = buff.String()
	return
}
func (m *DataUserBase) GetFieldID(ks []string) (p []interface{}) {
	if nil == m.XXX_Add {
		m.XXX_Add = make(map[string]interface{})
	}
	m.XXX_Add["UserUID"] = &m.UserUID
	m.XXX_Add["PlayerID"] = &m.PlayerID
	m.XXX_Add["Posx"] = &m.Posx
	m.XXX_Add["Posy"] = &m.Posy
	m.XXX_Add["Head"] = &m.Head
	m.XXX_Add["Nick"] = &m.Nick
	m.XXX_Add["City"] = &m.City
	m.XXX_Add["Sex"] = &m.Sex
	m.XXX_Add["Age"] = &m.Age
	m.XXX_Add["Level"] = &m.Level
	p = make([]interface{}, len(ks))
	j := 0
	for _, v := range ks {
		if d, ok := m.XXX_Add[v]; ok && nil != d {
			p[j] = d
			j += 1
		}
	}
	return
}
func (m *DataUserBase) RedisSet(key interface{}) (table string, data []interface{}) {
	table = "DataUserBase" + "_" + fmt.Sprint(key)
	data = make([]interface{}, 2*len(m.XXX_Update2))
	j := 0
	for k, v := range m.XXX_Update2 {
		data[j] = k
		data[j+1] = v
		j += 2
	}
	return
}
func (m *DataUserBase) RedisGet(key interface{}) (table string, data []string) {
	table = "DataUserBase" + "_" + fmt.Sprint(key)
	if len(m.XXX_Update) == 0 {
		data = make([]string, 10)
		data[0] = "UserUID"
		data[1] = "PlayerID"
		data[2] = "Posx"
		data[3] = "Posy"
		data[4] = "Head"
		data[5] = "Nick"
		data[6] = "City"
		data[7] = "Sex"
		data[8] = "Age"
		data[9] = "Level"
	} else {
		data = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			data[j] = k
			j += 1
		}
	}
	return
}
func (m *DataUserBase) RedisDel(key interface{}) (table string, data []string) {
	table = "DataUserBase" + "_" + fmt.Sprint(key)
	data = make([]string, len(m.XXX_Update))
	j := 0
	for k, _ := range m.XXX_Update {
		data[j] = k
		j += 1
	}
	return
}
func (m *DataUserBase) DoUpdate() (sql, table string, data []interface{}) {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserBase")
	buff.WriteString(" SET ")
	i := 0
	j := 0
	data = make([]interface{}, 2*len(m.XXX_Update))
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
		data[j] = k
		if val, ok := m.XXX_Update2[k]; ok {
			data[j+1] = val
		} else {
			data[j+1] = nil
		}
		j += 2
		delete(m.XXX_Update, k)
		delete(m.XXX_Update2, k)
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		table = "DataUserBase" + "_" + d
		i += 1
	}
	sql = buff.String()
	return
}

func (m *DataUserBase) GetUserUID() int64 {
	if m != nil {
		return m.UserUID
	}
	return 0
}

func (m *DataUserBase) GetPlayerID() int64 {
	if m != nil {
		return m.PlayerID
	}
	return 0
}

func (m *DataUserBase) GetPosx() float64 {
	if m != nil {
		return m.Posx
	}
	return 0
}

func (m *DataUserBase) GetPosy() float64 {
	if m != nil {
		return m.Posy
	}
	return 0
}

func (m *DataUserBase) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *DataUserBase) GetNick() string {
	if m != nil {
		return m.Nick
	}
	return ""
}

func (m *DataUserBase) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *DataUserBase) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *DataUserBase) GetAge() int32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *DataUserBase) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *DataUserBase) SetUserUID(data int64) {
	if m != nil {
		m.UserUID = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["UserUID"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["UserUID"] = data
	}
}

func (m *DataUserBase) SetKeyUserUID(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["UserUID"] = data
	}
}

func (m *DataUserBase) SetPlayerID(data int64) {
	if m != nil {
		m.PlayerID = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["PlayerID"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["PlayerID"] = data
	}
}

func (m *DataUserBase) SetKeyPlayerID(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["PlayerID"] = data
	}
}

func (m *DataUserBase) SetPosx(data float64) {
	if m != nil {
		m.Posx = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Posx"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Posx"] = data
	}
}

func (m *DataUserBase) SetKeyPosx(data float64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Posx"] = data
	}
}

func (m *DataUserBase) SetPosy(data float64) {
	if m != nil {
		m.Posy = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Posy"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Posy"] = data
	}
}

func (m *DataUserBase) SetKeyPosy(data float64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Posy"] = data
	}
}

func (m *DataUserBase) SetHead(data string) {
	if m != nil {
		m.Head = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Head"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Update["Head"] = data
	}
}

func (m *DataUserBase) SetKeyHead(data string) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Key["Head"] = data
	}
}

func (m *DataUserBase) SetNick(data string) {
	if m != nil {
		m.Nick = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Nick"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Update["Nick"] = data
	}
}

func (m *DataUserBase) SetKeyNick(data string) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Key["Nick"] = data
	}
}

func (m *DataUserBase) SetCity(data string) {
	if m != nil {
		m.City = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["City"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Update["City"] = data
	}
}

func (m *DataUserBase) SetKeyCity(data string) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		data = strconv.Quote(data)
		m.XXX_Key["City"] = data
	}
}

func (m *DataUserBase) SetSex(data int32) {
	if m != nil {
		m.Sex = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Sex"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Sex"] = data
	}
}

func (m *DataUserBase) SetKeySex(data int32) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Sex"] = data
	}
}

func (m *DataUserBase) SetAge(data int32) {
	if m != nil {
		m.Age = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Age"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Age"] = data
	}
}

func (m *DataUserBase) SetKeyAge(data int32) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Age"] = data
	}
}

func (m *DataUserBase) SetLevel(data int32) {
	if m != nil {
		m.Level = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Level"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Level"] = data
	}
}

func (m *DataUserBase) SetKeyLevel(data int32) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Level"] = data
	}
}

type DataUserAdd struct {
	UserID               int64                  `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	Coin                 int64                  `protobuf:"varint,2,opt,name=coin,proto3" json:"coin,omitempty"`
	Gold                 int64                  `protobuf:"varint,3,opt,name=gold,proto3" json:"gold,omitempty"`
	Viplevel             int32                  `protobuf:"varint,4,opt,name=viplevel,proto3" json:"viplevel,omitempty"`
	XXX_Update           map[string]interface{} `json:"-"`
	XXX_Update2          map[string]interface{} `json:"-"`
	XXX_Key              map[string]interface{} `json:"-"`
	XXX_Add              map[string]interface{} `json:"-"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DataUserAdd) Reset()         { *m = DataUserAdd{} }
func (m *DataUserAdd) String() string { return proto.CompactTextString(m) }
func (*DataUserAdd) ProtoMessage()    {}
func (*DataUserAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{2}
}

func (m *DataUserAdd) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DataUserAdd.Unmarshal(m, b)
}
func (m *DataUserAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DataUserAdd.Marshal(b, m, deterministic)
}
func (m *DataUserAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataUserAdd.Merge(m, src)
}
func (m *DataUserAdd) XXX_Size() int {
	return xxx_messageInfo_DataUserAdd.Size(m)
}
func (m *DataUserAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_DataUserAdd.DiscardUnknown(m)
}

var xxx_messageInfo_DataUserAdd proto.InternalMessageInfo

func (m *DataUserAdd) GetName() string {
	var buff bytes.Buffer
	buff.WriteString("DataUserAdd")
	data := strconv.Quote(buff.String())
	return data
}
func (m *DataUserAdd) DBDel() string {
	var buff bytes.Buffer
	buff.WriteString("DELETE FROM ")
	buff.WriteString("DataUserAdd")
	buff.WriteString(" WHERE ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserAdd) DBInsert() string {
	var buff bytes.Buffer
	buff.WriteString("INSERT INTO ")
	buff.WriteString("DataUserAdd")
	buff.WriteString("( ")
	i := 0
	var key bytes.Buffer
	var value bytes.Buffer
	for k, v := range m.XXX_Update {
		if i > 0 {
			key.WriteString(", ")
			value.WriteString(", ")
		}
		key.WriteString(k)
		d := fmt.Sprint(v)
		value.WriteString(d)
		i += 1
	}
	buff.WriteString(key.String())
	buff.WriteString(" ) VALUES ( ")
	buff.WriteString(value.String())
	buff.WriteString(" )")
	return buff.String()
}
func (m *DataUserAdd) DBUpdate() string {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserAdd")
	buff.WriteString(" SET ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserAdd) DBSelect() (s string, ks []string) {
	var buff bytes.Buffer
	buff.WriteString("SELECT ")
	i := 0
	if len(m.XXX_Update) == 0 {
		ks = make([]string, 4)
		ks[0] = "UserID"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("UserID")
		i += 1
		ks[1] = "Coin"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Coin")
		i += 1
		ks[2] = "Gold"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Gold")
		i += 1
		ks[3] = "Viplevel"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Viplevel")
		i += 1
	} else {
		ks = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			if i > 0 {
				buff.WriteString(", ")
			}
			buff.WriteString(k)
			ks[j] = k
			j += 1
			i += 1
		}
	}
	buff.WriteString(" FROM ")
	buff.WriteString("DataUserAdd")
	i = 0
	for k, v := range m.XXX_Key {
		if i == 0 {
			buff.WriteString(" WHERE ")
		}
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	s = buff.String()
	return
}
func (m *DataUserAdd) GetFieldID(ks []string) (p []interface{}) {
	if nil == m.XXX_Add {
		m.XXX_Add = make(map[string]interface{})
	}
	m.XXX_Add["UserID"] = &m.UserID
	m.XXX_Add["Coin"] = &m.Coin
	m.XXX_Add["Gold"] = &m.Gold
	m.XXX_Add["Viplevel"] = &m.Viplevel
	p = make([]interface{}, len(ks))
	j := 0
	for _, v := range ks {
		if d, ok := m.XXX_Add[v]; ok && nil != d {
			p[j] = d
			j += 1
		}
	}
	return
}
func (m *DataUserAdd) RedisSet(key interface{}) (table string, data []interface{}) {
	table = "DataUserAdd" + "_" + fmt.Sprint(key)
	data = make([]interface{}, 2*len(m.XXX_Update2))
	j := 0
	for k, v := range m.XXX_Update2 {
		data[j] = k
		data[j+1] = v
		j += 2
	}
	return
}
func (m *DataUserAdd) RedisGet(key interface{}) (table string, data []string) {
	table = "DataUserAdd" + "_" + fmt.Sprint(key)
	if len(m.XXX_Update) == 0 {
		data = make([]string, 4)
		data[0] = "UserID"
		data[1] = "Coin"
		data[2] = "Gold"
		data[3] = "Viplevel"
	} else {
		data = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			data[j] = k
			j += 1
		}
	}
	return
}
func (m *DataUserAdd) RedisDel(key interface{}) (table string, data []string) {
	table = "DataUserAdd" + "_" + fmt.Sprint(key)
	data = make([]string, len(m.XXX_Update))
	j := 0
	for k, _ := range m.XXX_Update {
		data[j] = k
		j += 1
	}
	return
}
func (m *DataUserAdd) DoUpdate() (sql, table string, data []interface{}) {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserAdd")
	buff.WriteString(" SET ")
	i := 0
	j := 0
	data = make([]interface{}, 2*len(m.XXX_Update))
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
		data[j] = k
		if val, ok := m.XXX_Update2[k]; ok {
			data[j+1] = val
		} else {
			data[j+1] = nil
		}
		j += 2
		delete(m.XXX_Update, k)
		delete(m.XXX_Update2, k)
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		table = "DataUserAdd" + "_" + d
		i += 1
	}
	sql = buff.String()
	return
}

func (m *DataUserAdd) GetUserID() int64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *DataUserAdd) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *DataUserAdd) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *DataUserAdd) GetViplevel() int32 {
	if m != nil {
		return m.Viplevel
	}
	return 0
}

func (m *DataUserAdd) SetUserID(data int64) {
	if m != nil {
		m.UserID = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["UserID"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["UserID"] = data
	}
}

func (m *DataUserAdd) SetKeyUserID(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["UserID"] = data
	}
}

func (m *DataUserAdd) SetCoin(data int64) {
	if m != nil {
		m.Coin = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Coin"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Coin"] = data
	}
}

func (m *DataUserAdd) SetKeyCoin(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Coin"] = data
	}
}

func (m *DataUserAdd) SetGold(data int64) {
	if m != nil {
		m.Gold = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Gold"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Gold"] = data
	}
}

func (m *DataUserAdd) SetKeyGold(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Gold"] = data
	}
}

func (m *DataUserAdd) SetViplevel(data int32) {
	if m != nil {
		m.Viplevel = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Viplevel"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Viplevel"] = data
	}
}

func (m *DataUserAdd) SetKeyViplevel(data int32) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Viplevel"] = data
	}
}

type DataUserBag struct {
	UserId               int64                  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ItemUID              int64                  `protobuf:"varint,2,opt,name=itemUID,proto3" json:"itemUID,omitempty"`
	ItemId               int64                  `protobuf:"varint,3,opt,name=itemId,proto3" json:"itemId,omitempty"`
	Count                int64                  `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	CreateTime           int64                  `protobuf:"varint,5,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Pos                  int32                  `protobuf:"varint,6,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_Update           map[string]interface{} `json:"-"`
	XXX_Update2          map[string]interface{} `json:"-"`
	XXX_Key              map[string]interface{} `json:"-"`
	XXX_Add              map[string]interface{} `json:"-"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DataUserBag) Reset()         { *m = DataUserBag{} }
func (m *DataUserBag) String() string { return proto.CompactTextString(m) }
func (*DataUserBag) ProtoMessage()    {}
func (*DataUserBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_db1b6b0986796150, []int{3}
}

func (m *DataUserBag) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DataUserBag.Unmarshal(m, b)
}
func (m *DataUserBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DataUserBag.Marshal(b, m, deterministic)
}
func (m *DataUserBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataUserBag.Merge(m, src)
}
func (m *DataUserBag) XXX_Size() int {
	return xxx_messageInfo_DataUserBag.Size(m)
}
func (m *DataUserBag) XXX_DiscardUnknown() {
	xxx_messageInfo_DataUserBag.DiscardUnknown(m)
}

var xxx_messageInfo_DataUserBag proto.InternalMessageInfo

func (m *DataUserBag) GetName() string {
	var buff bytes.Buffer
	buff.WriteString("DataUserBag")
	data := strconv.Quote(buff.String())
	return data
}
func (m *DataUserBag) DBDel() string {
	var buff bytes.Buffer
	buff.WriteString("DELETE FROM ")
	buff.WriteString("DataUserBag")
	buff.WriteString(" WHERE ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserBag) DBInsert() string {
	var buff bytes.Buffer
	buff.WriteString("INSERT INTO ")
	buff.WriteString("DataUserBag")
	buff.WriteString("( ")
	i := 0
	var key bytes.Buffer
	var value bytes.Buffer
	for k, v := range m.XXX_Update {
		if i > 0 {
			key.WriteString(", ")
			value.WriteString(", ")
		}
		key.WriteString(k)
		d := fmt.Sprint(v)
		value.WriteString(d)
		i += 1
	}
	buff.WriteString(key.String())
	buff.WriteString(" ) VALUES ( ")
	buff.WriteString(value.String())
	buff.WriteString(" )")
	return buff.String()
}
func (m *DataUserBag) DBUpdate() string {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserBag")
	buff.WriteString(" SET ")
	i := 0
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	return buff.String()
}
func (m *DataUserBag) DBSelect() (s string, ks []string) {
	var buff bytes.Buffer
	buff.WriteString("SELECT ")
	i := 0
	if len(m.XXX_Update) == 0 {
		ks = make([]string, 6)
		ks[0] = "UserId"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("UserId")
		i += 1
		ks[1] = "ItemUID"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("ItemUID")
		i += 1
		ks[2] = "ItemId"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("ItemId")
		i += 1
		ks[3] = "Count"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Count")
		i += 1
		ks[4] = "CreateTime"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("CreateTime")
		i += 1
		ks[5] = "Pos"
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString("Pos")
		i += 1
	} else {
		ks = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			if i > 0 {
				buff.WriteString(", ")
			}
			buff.WriteString(k)
			ks[j] = k
			j += 1
			i += 1
		}
	}
	buff.WriteString(" FROM ")
	buff.WriteString("DataUserBag")
	i = 0
	for k, v := range m.XXX_Key {
		if i == 0 {
			buff.WriteString(" WHERE ")
		}
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
	}
	s = buff.String()
	return
}
func (m *DataUserBag) GetFieldID(ks []string) (p []interface{}) {
	if nil == m.XXX_Add {
		m.XXX_Add = make(map[string]interface{})
	}
	m.XXX_Add["UserId"] = &m.UserId
	m.XXX_Add["ItemUID"] = &m.ItemUID
	m.XXX_Add["ItemId"] = &m.ItemId
	m.XXX_Add["Count"] = &m.Count
	m.XXX_Add["CreateTime"] = &m.CreateTime
	m.XXX_Add["Pos"] = &m.Pos
	p = make([]interface{}, len(ks))
	j := 0
	for _, v := range ks {
		if d, ok := m.XXX_Add[v]; ok && nil != d {
			p[j] = d
			j += 1
		}
	}
	return
}
func (m *DataUserBag) RedisSet(key interface{}) (table string, data []interface{}) {
	table = "DataUserBag" + "_" + fmt.Sprint(key)
	data = make([]interface{}, 2*len(m.XXX_Update2))
	j := 0
	for k, v := range m.XXX_Update2 {
		data[j] = k
		data[j+1] = v
		j += 2
	}
	return
}
func (m *DataUserBag) RedisGet(key interface{}) (table string, data []string) {
	table = "DataUserBag" + "_" + fmt.Sprint(key)
	if len(m.XXX_Update) == 0 {
		data = make([]string, 6)
		data[0] = "UserId"
		data[1] = "ItemUID"
		data[2] = "ItemId"
		data[3] = "Count"
		data[4] = "CreateTime"
		data[5] = "Pos"
	} else {
		data = make([]string, len(m.XXX_Update))
		j := 0
		for k, _ := range m.XXX_Update {
			data[j] = k
			j += 1
		}
	}
	return
}
func (m *DataUserBag) RedisDel(key interface{}) (table string, data []string) {
	table = "DataUserBag" + "_" + fmt.Sprint(key)
	data = make([]string, len(m.XXX_Update))
	j := 0
	for k, _ := range m.XXX_Update {
		data[j] = k
		j += 1
	}
	return
}
func (m *DataUserBag) DoUpdate() (sql, table string, data []interface{}) {
	var buff bytes.Buffer
	buff.WriteString("UPDATE ")
	buff.WriteString("DataUserBag")
	buff.WriteString(" SET ")
	i := 0
	j := 0
	data = make([]interface{}, 2*len(m.XXX_Update))
	for k, v := range m.XXX_Update {
		if i > 0 {
			buff.WriteString(", ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		i += 1
		data[j] = k
		if val, ok := m.XXX_Update2[k]; ok {
			data[j+1] = val
		} else {
			data[j+1] = nil
		}
		j += 2
		delete(m.XXX_Update, k)
		delete(m.XXX_Update2, k)
	}
	buff.WriteString(" WHERE ")
	i = 0
	for k, v := range m.XXX_Key {
		if i > 0 {
			buff.WriteString(" AND ")
		}
		buff.WriteString(k)
		d := fmt.Sprint(v)
		buff.WriteString(" = ")
		buff.WriteString(d)
		table = "DataUserBag" + "_" + d
		i += 1
	}
	sql = buff.String()
	return
}

func (m *DataUserBag) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DataUserBag) GetItemUID() int64 {
	if m != nil {
		return m.ItemUID
	}
	return 0
}

func (m *DataUserBag) GetItemId() int64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *DataUserBag) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *DataUserBag) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *DataUserBag) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *DataUserBag) SetUserId(data int64) {
	if m != nil {
		m.UserId = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["UserId"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["UserId"] = data
	}
}

func (m *DataUserBag) SetKeyUserId(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["UserId"] = data
	}
}

func (m *DataUserBag) SetItemUID(data int64) {
	if m != nil {
		m.ItemUID = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["ItemUID"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["ItemUID"] = data
	}
}

func (m *DataUserBag) SetKeyItemUID(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["ItemUID"] = data
	}
}

func (m *DataUserBag) SetItemId(data int64) {
	if m != nil {
		m.ItemId = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["ItemId"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["ItemId"] = data
	}
}

func (m *DataUserBag) SetKeyItemId(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["ItemId"] = data
	}
}

func (m *DataUserBag) SetCount(data int64) {
	if m != nil {
		m.Count = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Count"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Count"] = data
	}
}

func (m *DataUserBag) SetKeyCount(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Count"] = data
	}
}

func (m *DataUserBag) SetCreateTime(data int64) {
	if m != nil {
		m.CreateTime = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["CreateTime"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["CreateTime"] = data
	}
}

func (m *DataUserBag) SetKeyCreateTime(data int64) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["CreateTime"] = data
	}
}

func (m *DataUserBag) SetPos(data int32) {
	if m != nil {
		m.Pos = data
		if nil == m.XXX_Update2 {
			m.XXX_Update2 = make(map[string]interface{})
		}
		m.XXX_Update2["Pos"] = data
		if nil == m.XXX_Update {
			m.XXX_Update = make(map[string]interface{})
		}
		m.XXX_Update["Pos"] = data
	}
}

func (m *DataUserBag) SetKeyPos(data int32) {
	if m != nil {
		if nil == m.XXX_Key {
			m.XXX_Key = make(map[string]interface{})
		}
		m.XXX_Key["Pos"] = data
	}
}

func init() {
	proto.RegisterType((*DataUserAccount)(nil), "msg.DataUserAccount")
	proto.RegisterType((*DataUserBase)(nil), "msg.DataUserBase")
	proto.RegisterType((*DataUserAdd)(nil), "msg.DataUserAdd")
	proto.RegisterType((*DataUserBag)(nil), "msg.DataUserBag")
}

func init() { proto.RegisterFile("base.proto", fileDescriptor_db1b6b0986796150) }

var fileDescriptor_db1b6b0986796150 = []byte{
	// 361 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x92, 0x4f, 0x4e, 0xf3, 0x30,
	0x10, 0xc5, 0xe5, 0xcf, 0x4d, 0xff, 0xf8, 0x43, 0x02, 0x59, 0x08, 0x59, 0x08, 0xa1, 0x2a, 0xab,
	0xae, 0xd8, 0x70, 0x02, 0xaa, 0x6c, 0xb2, 0xb5, 0xe8, 0x01, 0xdc, 0x64, 0x94, 0x5a, 0x24, 0x71,
	0x14, 0xa7, 0xa5, 0x39, 0x08, 0x6b, 0xee, 0xc6, 0x49, 0xd0, 0x8c, 0x93, 0x14, 0x36, 0xec, 0xde,
	0xfb, 0x8d, 0xdc, 0x37, 0xf3, 0x1a, 0x21, 0xf6, 0xc6, 0xc3, 0x53, 0xd3, 0xba, 0xce, 0x49, 0x5e,
	0xf9, 0x22, 0xfe, 0x60, 0xe2, 0x3a, 0x31, 0x9d, 0xd9, 0x79, 0x68, 0x5f, 0xb2, 0xcc, 0x1d, 0xeb,
	0x4e, 0x2a, 0xb1, 0x38, 0x7a, 0x68, 0x77, 0x69, 0xa2, 0xd8, 0x9a, 0x6d, 0xb8, 0x1e, 0x2d, 0x4e,
	0x9a, 0x83, 0xab, 0x21, 0x4d, 0xd4, 0xbf, 0x35, 0xdb, 0xac, 0xf4, 0x68, 0xe5, 0x83, 0x58, 0x99,
	0xf0, 0x3c, 0x4d, 0x14, 0xa7, 0xd9, 0x05, 0xc8, 0x7b, 0xb1, 0x6c, 0x8c, 0xf7, 0xef, 0xae, 0xcd,
	0xd5, 0x8c, 0x86, 0x93, 0x97, 0xb7, 0x22, 0x82, 0xca, 0xd8, 0x52, 0x45, 0x34, 0x08, 0x26, 0xfe,
	0x62, 0xe2, 0x6a, 0xdc, 0x6b, 0x6b, 0x3c, 0xfc, 0xb1, 0x14, 0xfe, 0x78, 0x69, 0x7a, 0x68, 0x87,
	0xad, 0xb8, 0x9e, 0xbc, 0x94, 0x62, 0xd6, 0x38, 0x7f, 0xa6, 0x8d, 0x98, 0x26, 0x3d, 0xb0, 0x9e,
	0x16, 0x09, 0xac, 0x47, 0x76, 0x00, 0x93, 0x0f, 0x3b, 0x90, 0x46, 0x56, 0xdb, 0xec, 0x4d, 0xcd,
	0x03, 0x43, 0x8d, 0x2c, 0xb3, 0x5d, 0xaf, 0x16, 0x81, 0xa1, 0x96, 0x37, 0x82, 0x7b, 0x38, 0xab,
	0xe5, 0x9a, 0x6d, 0x22, 0x8d, 0x12, 0x89, 0x29, 0x40, 0xad, 0x02, 0x31, 0x05, 0xe0, 0x91, 0x25,
	0x9c, 0xa0, 0x54, 0x82, 0x58, 0x30, 0xb1, 0x15, 0xff, 0xa7, 0xee, 0xf3, 0x5c, 0xde, 0x89, 0x39,
	0xde, 0x34, 0x5d, 0x38, 0x38, 0x0a, 0x75, 0xb6, 0x1e, 0x8e, 0x23, 0x8d, 0xac, 0x70, 0x65, 0x4e,
	0x87, 0x71, 0x4d, 0x1a, 0x8b, 0x38, 0xd9, 0x26, 0xe4, 0xcc, 0x28, 0x67, 0xf2, 0xf1, 0x27, 0xbb,
	0x64, 0x6d, 0x4d, 0x31, 0x65, 0xe5, 0xbf, 0xb2, 0x72, 0xac, 0xd9, 0x76, 0x50, 0xed, 0xa6, 0x2e,
	0x47, 0x8b, 0x2f, 0x50, 0xa6, 0x63, 0xe6, 0xe0, 0xf0, 0x34, 0xfa, 0x9b, 0x29, 0x92, 0xeb, 0x60,
	0xe4, 0xa3, 0x10, 0x59, 0x0b, 0xa6, 0x83, 0x57, 0x5b, 0x01, 0xd5, 0xca, 0xf5, 0x0f, 0x82, 0x15,
	0x35, 0xce, 0x53, 0xb7, 0x91, 0x46, 0xb9, 0x9f, 0xd3, 0x57, 0xf9, 0xfc, 0x1d, 0x00, 0x00, 0xff,
	0xff, 0x83, 0x7f, 0x51, 0x61, 0xa3, 0x02, 0x00, 0x00,
}
